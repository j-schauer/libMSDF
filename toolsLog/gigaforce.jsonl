{"timestamp":"2026-02-18T18:35:21.982Z","gigatron_version":"4.0.0","logging_info":{"requested_dir":null,"actual_dir":"./toolsLog"},"query":{"model":["g5","gemini","deepseek"],"subject":"Compiling HarfBuzz to WebAssembly with Emscripten alongside FreeType - complete practical guide","generalOverview":"I need to compile HarfBuzz to WebAssembly using Emscripten for use in a browser-based text rendering system. The project already compiles FreeType via Emscripten's built-in port (-sUSE_FREETYPE=1). I need to integrate HarfBuzz for proper text shaping/layout alongside FreeType for rasterization. I need concrete, practical information - actual API calls, compilation commands, source file lists, not general concepts.","issueDetails":"I need detailed answers to ALL of the following:\n\n1. **HarfBuzz source**: What is the GitHub repo URL? What's the build system (cmake, meson, autotools)? What's the latest stable version? Can it be added as a git submodule? What's the directory structure?\n\n2. **Emscripten compilation**: \n   - Exact emcc/emcmake commands to compile HarfBuzz to WASM\n   - Required compiler flags and defines\n   - Does HarfBuzz have built-in Emscripten/WASM support or cmake toolchain files?\n   - How to disable unnecessary subsystems (CoreText, DirectWrite, GDI, ICU, etc.)\n   - The minimal set of cmake options for a WASM build with FreeType support only\n   - Can you bypass the build system entirely and just compile the .cc files directly with emcc?\n\n3. **FreeType integration**:\n   - HarfBuzz has an hb-ft.h header for FreeType integration. What exactly does it provide?\n   - What defines are needed (HAVE_FREETYPE, HB_HAVE_FREETYPE, etc.)?\n   - The project already uses Emscripten's -sUSE_FREETYPE=1 port. Can HarfBuzz link against that same FreeType?\n   - What are the exact function signatures in hb-ft.h?\n\n4. **The complete layout API with code examples**:\n   - hb_ft_font_create() - exact signature, parameters, what it returns\n   - hb_buffer_create(), hb_buffer_add_utf8() or hb_buffer_add_utf16() \n   - hb_buffer_set_direction(), hb_buffer_set_script(), hb_buffer_set_language()\n   - hb_buffer_guess_segment_properties()\n   - hb_shape() - exact call\n   - hb_buffer_get_glyph_infos() and hb_buffer_get_glyph_positions() - what do the output structs look like?\n   - hb_glyph_info_t and hb_glyph_position_t struct definitions with field explanations\n   - Complete working C code example that shapes \"AVATAR\" and prints glyph IDs and positions\n\n5. **OpenType features API**:\n   - hb_feature_t struct\n   - hb_feature_from_string()\n   - How to pass features to hb_shape()\n   - Code example enabling/disabling kern, liga, etc.\n\n6. **Font metrics**: Does HarfBuzz provide hb_font_get_extents() or similar? What's in hb_font_extents_t? Or should font metrics (ascender, descender, line gap) come from FreeType?\n\n7. **WASM size**: Typical compiled size of HarfBuzz as WASM. What subsystems add the most size? What's the minimal build?\n\n8. **Source file compilation**: \n   - HarfBuzz has a single-file compilation mode (hb.cc or harfbuzz.cc that includes everything). What is it?\n   - What are the key source files if compiling individually?\n   - Can you literally just do: emcc -DHB_HAVE_FREETYPE hb.cc -o hb.o and have it work?\n\nPlease provide ACTUAL code, ACTUAL commands, ACTUAL file names. Not general descriptions.","requestObjective":"Provide a complete, concrete, practical guide with actual code snippets, exact compilation commands, exact API calls, and exact file names for compiling HarfBuzz to WASM with Emscripten and using it for text layout alongside FreeType.","referenceURLs":["https://github.com/harfbuzz/harfbuzz","https://harfbuzz.github.io/","https://harfbuzz.github.io/integration-freetype.html","https://harfbuzz.github.io/shaping-and-shape-plans.html"],"filePaths":[],"output":null},"responses":[{"config_requested":"g5","config_used":"g5","model":"openai/gpt-5.2","response":"Below is a concrete, buildable “HarfBuzz + FreeType (Emscripten port) → WASM” guide. I’m going to give you **real commands, real file names, and real HarfBuzz API calls**. Where I’m not 100% sure (mainly “latest stable version number” and some Meson/CMake option names that have changed across releases), I’ll explicitly say so and tell you how to verify in-repo.\n\n---\n\n## 1) HarfBuzz source (repo, build system, versions, submodule, layout)\n\n### Repo URL\n- **Main repo:** https://github.com/harfbuzz/harfbuzz\n\n### Build system(s)\nHarfBuzz supports (varies a bit by version):\n- **Meson** (primary / recommended in recent versions)\n- **Autotools** (historical; still present in many releases)\n- **CMake**: present in many versions, but the completeness/options have evolved. You can usually build HarfBuzz with CMake, but Meson tends to be the “first-class” path.\n\n**Verify in your checkout**:\n```bash\nls\n# Look for: meson.build, configure.ac, CMakeLists.txt\n```\n\n### Latest stable version\nI can’t reliably assert the “latest stable” number without live access. HarfBuzz releases frequently (8.x/9.x/10.x era). Use:\n- https://github.com/harfbuzz/harfbuzz/releases (authoritative)\n- Or locally:\n```bash\ngit ls-remote --tags https://github.com/harfbuzz/harfbuzz.git | tail\n```\n\n### Add as git submodule\nYes:\n```bash\ngit submodule add https://github.com/harfbuzz/harfbuzz.git third_party/harfbuzz\ngit submodule update --init --recursive\n```\n\n### Directory structure (typical)\nIn `third_party/harfbuzz/` you’ll commonly see:\n- `src/` — **the library source** (this is what you compile)\n  - `harfbuzz.cc` — **amalgamation** TU (single-file build of core)\n  - `hb-ft.cc`, `hb-ft.h` — FreeType integration\n  - Lots of `hb-*.cc`, `hb-ot-*.cc` etc if building non-amalgamated\n- `test/` — tests\n- `util/` — command-line tools (hb-shape, hb-view, etc.)\n- `docs/`\n- `subprojects/` — Meson wrap dependencies (optional)\n\n---\n\n## 2) Emscripten compilation (exact commands, flags, disabling subsystems)\n\nYou have three practical paths:\n\n1. **Meson build** (recommended if it works cleanly in your environment)\n2. **CMake build** (often works; options differ by version)\n3. **Amalgamation build**: compile `src/harfbuzz.cc` (+ `src/hb-ft.cc`) directly with `em++` (most deterministic for WASM if you control defines)\n\nI’ll give all three.\n\n---\n\n### 2A) Build HarfBuzz with Meson + Emscripten (static lib)\n\n#### 1) Create an Emscripten cross file\nCreate `emscripten.cross.ini`:\n\n```ini\n[binaries]\nc = 'emcc'\ncpp = 'em++'\nar = 'emar'\nranlib = 'emranlib'\nstrip = 'llvm-strip'\npkgconfig = 'pkg-config'\n\n[host_machine]\nsystem = 'emscripten'\ncpu_family = 'wasm32'\ncpu = 'wasm32'\nendian = 'little'\n\n[properties]\nneeds_exe_wrapper = true\n```\n\n#### 2) Configure Meson\nFrom your project root:\n\n```bash\ncd third_party/harfbuzz\n\n# NOTE: option names change across HarfBuzz versions.\n# If any -Dfoo=... fails, run: meson setup build-wasm --cross-file=... then `meson configure build-wasm`\n# to see the exact option names in that version.\n\nemconfigure meson setup build-wasm \\\n  --cross-file ../emscripten.cross.ini \\\n  --default-library=static \\\n  -Dbuildtype=release \\\n  -Dtests=disabled \\\n  -Dbenchmarks=disabled \\\n  -Dintrospection=disabled \\\n  -Ddocs=disabled \\\n  -Dglib=disabled \\\n  -Dgobject=disabled \\\n  -Dicu=disabled \\\n  -Dgraphite2=disabled \\\n  -Dcairo=disabled \\\n  -Dfreetype=enabled\n```\n\nThen build:\n```bash\nninja -C build-wasm\n```\n\nYou should get something like:\n- `third_party/harfbuzz/build-wasm/src/libharfbuzz.a`\n- optionally `.../libharfbuzz-subset.a` depending on defaults/options\n\n**If Meson tries to execute built tools** (common cross-compile issue), ensure `needs_exe_wrapper=true` and that Meson isn’t configured to build utilities. Many versions have a `-Dutilities=disabled` or similar—check via:\n```bash\nmeson configure build-wasm\n```\n\n**Does HarfBuzz have built-in “Emscripten support”?**\nNo special official “Emscripten toolchain file” is required; it’s a normal cross-compile. The “official-ish” WASM work is in:\n- https://github.com/harfbuzz/harfbuzzjs (build scripts + bindings)\n- https://github.com/harfbuzz/harfbuzz-wasm-examples\n\n---\n\n### 2B) Build HarfBuzz with CMake + emcmake (static lib)\n\nThis is the most common pattern:\n\n```bash\ncd third_party/harfbuzz\n\nemcmake cmake -S . -B build-wasm-cmake \\\n  -DCMAKE_BUILD_TYPE=Release \\\n  -DBUILD_SHARED_LIBS=OFF\n```\n\nNow: **HarfBuzz CMake option names vary by version**. Run:\n```bash\ncmake -LA -N build-wasm-cmake | sed -n 's/^\\(HB_[A-Z0-9_]*\\):.*/\\1/p'\n```\n\nWhat you want conceptually is:\n- **enable freetype**\n- **disable** ICU, GLib/GObject, Graphite2, Cairo, and platform shapers (CoreText/DirectWrite/GDI/Uniscribe)\n- **disable** utils/tests/benchmarks to avoid host executables\n\nIn many versions, these exist (but confirm with `cmake -LA`):\n- `HB_HAVE_FREETYPE`\n- `HB_HAVE_ICU`\n- `HB_HAVE_GLIB`\n- `HB_HAVE_GOBJECT`\n- `HB_HAVE_GRAPHITE2`\n- `HB_BUILD_UTILS`\n- `HB_BUILD_TESTS`\n- `HB_BUILD_SUBSET` (disable if you only need shaping)\n\nExample (adjust names to what your `cmake -LA` shows):\n```bash\nemcmake cmake -S . -B build-wasm-cmake \\\n  -DCMAKE_BUILD_TYPE=Release \\\n  -DBUILD_SHARED_LIBS=OFF \\\n  -DHB_BUILD_UTILS=OFF \\\n  -DHB_BUILD_TESTS=OFF \\\n  -DHB_BUILD_SUBSET=OFF \\\n  -DHB_HAVE_FREETYPE=ON \\\n  -DHB_HAVE_ICU=OFF \\\n  -DHB_HAVE_GLIB=OFF \\\n  -DHB_HAVE_GOBJECT=OFF \\\n  -DHB_HAVE_GRAPHITE2=OFF\n\ncmake --build build-wasm-cmake -j\n```\n\n---\n\n### 2C) Bypass build system: compile the **amalgamation** with `em++`\n\nThis is the most “practical and explicit” path for WASM, **but** you must handle HarfBuzz configuration macros (normally generated by Meson/CMake). HarfBuzz supports an override header mechanism.\n\n#### Files you compile\n- `third_party/harfbuzz/src/harfbuzz.cc`  (**core HarfBuzz amalgamation**)\n- `third_party/harfbuzz/src/hb-ft.cc`     (**FreeType integration**)\n\n#### Create a config override header\nCreate `third_party/harfbuzz-wasm/hb-config-override.h` (location is up to you):\n\n```c\n#pragma once\n\n/* Keep it minimal: enable FreeType integration, disable other deps. */\n#define HB_HAVE_FREETYPE 1\n#define HAVE_FREETYPE 1\n\n#define HB_HAVE_GLIB 0\n#define HAVE_GLIB 0\n\n#define HB_HAVE_ICU 0\n#define HAVE_ICU 0\n\n#define HB_HAVE_GRAPHITE2 0\n#define HAVE_GRAPHITE2 0\n\n/* Optional size/simplicity knobs (safe for single-threaded WASM) */\n#define HB_NO_MT 1\n```\n\n> Notes:\n> - `HB_HAVE_FREETYPE` is the key macro HarfBuzz uses around hb-ft integration.\n> - Some versions also check `HAVE_FREETYPE`. Defining both is common practice.\n\n#### Compile to a static library\n```bash\nHB=third_party/harfbuzz\nOVR=third_party/harfbuzz-wasm/hb-config-override.h\n\nem++ -std=c++17 -O3 -DNDEBUG \\\n  -fno-exceptions -fno-rtti \\\n  -DHB_CONFIG_OVERRIDE_H=\\\"$(pwd)/$OVR\\\" \\\n  -I$HB/src \\\n  -sUSE_FREETYPE=1 \\\n  -c $HB/src/harfbuzz.cc -o harfbuzz.o\n\nem++ -std=c++17 -O3 -DNDEBUG \\\n  -fno-exceptions -fno-rtti \\\n  -DHB_CONFIG_OVERRIDE_H=\\\"$(pwd)/$OVR\\\" \\\n  -I$HB/src \\\n  -sUSE_FREETYPE=1 \\\n  -c $HB/src/hb-ft.cc -o hb-ft.o\n\nemar rcs libharfbuzz_wasm.a harfbuzz.o hb-ft.o\n```\n\nThis produces `libharfbuzz_wasm.a` you can link into your own WASM module.\n\n**Does “`emcc -DHB_HAVE_FREETYPE hb.cc -o hb.o`” work?**\n- The file is not usually `hb.cc`; it’s **`src/harfbuzz.cc`** (amalgamation).\n- You must compile as **C++** (use `em++`), and you almost always need the config override approach above.\n- You must also compile **`hb-ft.cc`** if you want `hb_ft_*` API.\n\n---\n\n## 3) FreeType integration (hb-ft.h, defines, linking with `-sUSE_FREETYPE=1`, signatures)\n\n### What `hb-ft.h` provides\n`hb-ft.h` is HarfBuzz’s integration layer that lets you:\n- Create `hb_face_t` / `hb_font_t` from an **existing `FT_Face`**\n- Make HarfBuzz obtain glyph advances/metrics via FreeType (including hinted metrics if you configure FreeType that way)\n- Set/get FreeType load flags and size parameters on the HarfBuzz font wrapper\n\nThis is useful when:\n- You already use FreeType to load fonts (as you do)\n- You want shaped glyph positions that match FreeType’s metrics/hinting behavior\n\n### Defines/macros\nCommon macros:\n- `HB_HAVE_FREETYPE` (HarfBuzz-side)\n- sometimes also `HAVE_FREETYPE`\n\nIf you build via Meson/CMake, these come from generated config headers.\nIf you build manually, define them or use `HB_CONFIG_OVERRIDE_H` as shown.\n\n### Can HarfBuzz link against Emscripten’s port `-sUSE_FREETYPE=1`?\nYes. Practical rules:\n- When compiling HarfBuzz objects that include `<ft2build.h>` you must pass `-sUSE_FREETYPE=1` (so include paths are present).\n- When linking your final WASM module, you must also pass `-sUSE_FREETYPE=1` so the FreeType library is linked in.\n\n### Key function signatures in `hb-ft.h`\nThese signatures are stable across many releases (verify in your version at `src/hb-ft.h`):\n\n```c\nHB_EXTERN hb_face_t *\nhb_ft_face_create (FT_Face ft_face, hb_destroy_func_t destroy);\n\nHB_EXTERN hb_face_t *\nhb_ft_face_create_referenced (FT_Face ft_face);\n\nHB_EXTERN hb_font_t *\nhb_ft_font_create (FT_Face ft_face, hb_destroy_func_t destroy);\n\nHB_EXTERN hb_font_t *\nhb_ft_font_create_referenced (FT_Face ft_face);\n\nHB_EXTERN void\nhb_ft_font_set_funcs (hb_font_t *font);\n\nHB_EXTERN FT_Face\nhb_ft_font_get_face (hb_font_t *font);\n\nHB_EXTERN void\nhb_ft_font_set_load_flags (hb_font_t *font, int load_flags);\n\nHB_EXTERN int\nhb_ft_font_get_load_flags (hb_font_t *font);\n\nHB_EXTERN void\nhb_ft_font_set_ppem (hb_font_t *font, unsigned int x_ppem, unsigned int y_ppem);\n\nHB_EXTERN void\nhb_ft_font_get_ppem (hb_font_t *font, unsigned int *x_ppem, unsigned int *y_ppem);\n\nHB_EXTERN void\nhb_ft_font_set_ptem (hb_font_t *font, float ptem);\n\nHB_EXTERN float\nhb_ft_font_get_ptem (hb_font_t *font);\n```\n\nSome versions also expose transform setters (matrix/delta). **Check your `hb-ft.h`** for extras.\n\n---\n\n## 4) Complete shaping/layout API (exact calls + working C example shaping “AVATAR”)\n\n### Core HarfBuzz calls you’ll use\n\n#### Create font from FreeType\n- `hb_font_t *hb_ft_font_create_referenced(FT_Face ft_face);`\n\nYou typically also set scale:\n- `void hb_font_set_scale(hb_font_t *font, int x_scale, int y_scale);`\n\n#### Buffer lifecycle & feeding text\n- `hb_buffer_t *hb_buffer_create(void);`\n- `void hb_buffer_destroy(hb_buffer_t *buffer);`\n- `void hb_buffer_add_utf8(hb_buffer_t *buffer, const char *text, int text_length, unsigned int item_offset, int item_length);`\n- (or) `hb_buffer_add_utf16(...)` / `hb_buffer_add_utf32(...)`\n\n#### Segment properties\n- `void hb_buffer_set_direction(hb_buffer_t *buffer, hb_direction_t direction);`\n- `void hb_buffer_set_script(hb_buffer_t *buffer, hb_script_t script);`\n- `void hb_buffer_set_language(hb_buffer_t *buffer, hb_language_t language);`\n- or simply: `void hb_buffer_guess_segment_properties(hb_buffer_t *buffer);`\n\n#### Shape\n- `void hb_shape(hb_font_t *font, hb_buffer_t *buffer, const hb_feature_t *features, unsigned int num_features);`\n\n#### Read results\n- `hb_glyph_info_t *hb_buffer_get_glyph_infos(hb_buffer_t *buffer, unsigned int *length);`\n- `hb_glyph_position_t *hb_buffer_get_glyph_positions(hb_buffer_t *buffer, unsigned int *length);`\n\n### Output structs (what they look like)\nFrom `hb-buffer.h` (confirm in your version):\n\n```c\ntypedef struct hb_glyph_info_t {\n  hb_codepoint_t codepoint; /* glyph id */\n  hb_mask_t      mask;      /* internal; also used for feature masking */\n  uint32_t       cluster;   /* index of original text cluster */\n  hb_var_int_t   var1;\n  hb_var_int_t   var2;\n} hb_glyph_info_t;\n\ntypedef struct hb_glyph_position_t {\n  hb_position_t  x_advance;\n  hb_position_t  y_advance;\n  hb_position_t  x_offset;\n  hb_position_t  y_offset;\n  hb_var_int_t   var;\n} hb_glyph_position_t;\n```\n\nField meanings you usually care about:\n- `info[i].codepoint` = **glyph ID** (in the font)\n- `info[i].cluster` = byte/UTF index (depends on input API) of source text cluster\n- `pos[i].x_advance`, `y_advance` = how much to move pen after drawing glyph\n- `pos[i].x_offset`, `y_offset` = offset for this glyph from current pen\n\n**Units:** `hb_position_t` is an integer in whatever scale your `hb_font_t` is set to. If you set scale to “font units per EM” you get font units; if you set it to 26.6 pixels you get 26.6 pixels.\n\n---\n\n### Working C example: shape \"AVATAR\" and print glyph ids + positions\n\nThis example assumes:\n- You have a font file available at runtime as `\"font.ttf\"` (Emscripten: preload it with `--preload-file font.ttf` or embed it yourself).\n- You compile and link with HarfBuzz + FreeType (`-sUSE_FREETYPE=1` and your HarfBuzz `.a`)\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n#include <ft2build.h>\n#include FT_FREETYPE_H\n\n#include <hb.h>\n#include <hb-ft.h>\n\nstatic void die(const char* msg) {\n  fprintf(stderr, \"fatal: %s\\n\", msg);\n  exit(1);\n}\n\nint main() {\n  const char *font_path = \"font.ttf\";\n  const char *text = \"AVATAR\";\n\n  /* 1) Init FreeType and load face */\n  FT_Library ft_library;\n  if (FT_Init_FreeType(&ft_library)) die(\"FT_Init_FreeType failed\");\n\n  FT_Face ft_face;\n  if (FT_New_Face(ft_library, font_path, 0, &ft_face)) die(\"FT_New_Face failed\");\n\n  /* Set a size (important if you want pixel-ish metrics via FT) */\n  /* 48pt at 72dpi => 48px nominal; adjust as needed */\n  if (FT_Set_Char_Size(ft_face, 0, 48 * 64, 72, 72)) die(\"FT_Set_Char_Size failed\");\n\n  /* 2) Create HarfBuzz font from FT_Face */\n  hb_font_t *hb_font = hb_ft_font_create_referenced(ft_face);\n\n  /* Pick a scale.\n     Option A: use font units-per-em (design units) */\n  /* hb_font_set_scale(hb_font, ft_face->units_per_EM, ft_face->units_per_EM); */\n\n  /* Option B: use 26.6 pixel units derived from current FT size */\n  hb_font_set_scale(hb_font,\n                    (int)ft_face->size->metrics.x_ppem * 64,\n                    (int)ft_face->size->metrics.y_ppem * 64);\n\n  /* You can control hinting/metrics here */\n  hb_ft_font_set_load_flags(hb_font, FT_LOAD_DEFAULT);\n\n  /* 3) Create buffer and add text */\n  hb_buffer_t *buf = hb_buffer_create();\n  hb_buffer_add_utf8(buf, text, -1, 0, -1);\n\n  /* Set properties (or guess) */\n  hb_buffer_set_direction(buf, HB_DIRECTION_LTR);\n  hb_buffer_set_script(buf, HB_SCRIPT_LATIN);\n  hb_buffer_set_language(buf, hb_language_from_string(\"en\", -1));\n  /* hb_buffer_guess_segment_properties(buf); */\n\n  /* 4) Shape (no features) */\n  hb_shape(hb_font, buf, NULL, 0);\n\n  /* 5) Extract results */\n  unsigned int glyph_count = 0;\n  hb_glyph_info_t *info = hb_buffer_get_glyph_infos(buf, &glyph_count);\n  hb_glyph_position_t *pos = hb_buffer_get_glyph_positions(buf, &glyph_count);\n\n  printf(\"Shaping result for \\\"%s\\\": %u glyphs\\n\", text, glyph_count);\n\n  int x = 0, y = 0;\n  for (unsigned int i = 0; i < glyph_count; i++) {\n    printf(\"gid=%u cluster=%u  x_off=%d y_off=%d  x_adv=%d y_adv=%d  pen=(%d,%d)\\n\",\n           (unsigned)info[i].codepoint,\n           (unsigned)info[i].cluster,\n           (int)pos[i].x_offset,\n           (int)pos[i].y_offset,\n           (int)pos[i].x_advance,\n           (int)pos[i].y_advance,\n           x, y);\n\n    x += pos[i].x_advance;\n    y += pos[i].y_advance;\n  }\n\n  /* 6) Cleanup */\n  hb_buffer_destroy(buf);\n  hb_font_destroy(hb_font);\n\n  FT_Done_Face(ft_face);\n  FT_Done_FreeType(ft_library);\n\n  return 0;\n}\n```\n\n---\n\n## 5) OpenType features API (hb_feature_t, hb_feature_from_string, passing to hb_shape)\n\n### `hb_feature_t` struct\nFrom `hb-common.h` (verify in your version):\n\n```c\ntypedef struct hb_feature_t {\n  hb_tag_t tag;\n  uint32_t value;\n  unsigned int start;\n  unsigned int end;\n} hb_feature_t;\n```\n\n- `tag` is a 4-byte OpenType feature tag (`'kern'`, `'liga'`, etc.)\n- `value` typically 0/1 for off/on, but some features take numeric values\n- `start/end` is the range in the buffer the feature applies to:\n  - `start = 0`, `end = (unsigned)-1` applies to whole buffer\n\n### Parse feature from string\n```c\nhb_feature_t feat;\nhb_bool_t ok = hb_feature_from_string(\"kern=1\", -1, &feat);\n```\n\n### Pass features to `hb_shape`\n```c\nhb_feature_t features[2];\nhb_feature_from_string(\"kern=1\", -1, &features[0]);\nhb_feature_from_string(\"liga=0\", -1, &features[1]);\n\nhb_shape(hb_font, buf, features, 2);\n```\n\n### Example: toggle kern/liga\n```c\nhb_feature_t feats[3];\nunsigned int n = 0;\n\nhb_feature_from_string(\"kern=1\", -1, &feats[n++]); /* enable kerning */\nhb_feature_from_string(\"liga=1\", -1, &feats[n++]); /* enable ligatures */\nhb_feature_from_string(\"liga=0\", -1, &feats[n++]); /* disable ligatures (overrides prior if later) */\n\nhb_shape(hb_font, buf, feats, n);\n```\n\n---\n\n## 6) Font metrics: HarfBuzz extents vs FreeType metrics\n\nYes, HarfBuzz exposes extents APIs. Common ones:\n\n- `hb_bool_t hb_font_get_h_extents(hb_font_t *font, hb_font_extents_t *extents);`\n- `hb_bool_t hb_font_get_v_extents(hb_font_t *font, hb_font_extents_t *extents);`\n\nAnd the struct:\n\n```c\ntypedef struct hb_font_extents_t {\n  hb_position_t ascender;\n  hb_position_t descender;\n  hb_position_t line_gap;\n} hb_font_extents_t;\n```\n\n**Which should you use in a FreeType pipeline?**\n- For browser text layout, line metrics (ascender/descender/line-gap) usually come from the font’s OS/2/hhea tables. Both HarfBuzz and FreeType can provide them.\n- If you use `hb-ft` integration, HarfBuzz can fetch extents via FreeType-backed funcs, which typically matches your FreeType rasterization/hinting configuration better.\n- Many engines still use **FreeType** for “authoritative” pixel metrics if they are already depending on it (e.g., `FT_Size_Metrics` + OS/2 tables via FreeType APIs if needed).\n\nPractical approach:\n- Use `hb_font_get_h_extents()` for shaping/layout metrics (same unit system as your hb_font scale).\n- Use FreeType for per-glyph bitmap metrics (bearing/bitmap top/left etc.) when rasterizing.\n\n---\n\n## 7) WASM size: what to expect and what increases size\n\nExact size depends heavily on:\n- optimization flags (`-Oz` vs `-O3`, LTO, dead-stripping),\n- whether you include subset/OT sanitizers,\n- whether you include ICU/Graphite2/GLib,\n- whether you compile as a separate module or link into a bigger app.\n\nTypical ballparks (very rough; measure your build):\n- **Minimal core shaping-only HarfBuzz (OT shaping), no ICU/Graphite2/GLib, no subset**:\n  - Often in the **few hundred KB** range as `.wasm` with `-Oz -flto`, sometimes ~300–700KB depending on exports and link-time GC.\n- Adding **subset** (`harfbuzz-subset`) can add a **lot** (tables/code for subsetting; can be hundreds of KB+).\n- Adding **ICU** is huge (MBs); don’t for WASM unless you truly need it.\n- Graphite2 also increases size.\n\n**Minimal build strategy**\n- Build **static**\n- Disable: ICU, GLib/GObject, Graphite2, Cairo, tests, utils, subset (if not needed)\n- Use:\n  - `-Oz`\n  - `-flto`\n  - `-fno-exceptions -fno-rtti`\n  - ensure link-time dead-code elimination (Emscripten/wasm-ld generally does this well, but don’t export everything)\n\n---\n\n## 8) Source file compilation (amalgamation, key files, “compile hb.cc directly?”)\n\n### Single-file (“amalgamation”) mode\nHarfBuzz provides:\n- `src/harfbuzz.cc` — amalgamation of the core HarfBuzz library\n\nDepending on version, there may also be:\n- `src/harfbuzz-subset.cc` — amalgamation for the subset library\n- `src/harfbuzz-icu.cc` — ICU integration amalgamation\n- `src/harfbuzz-gobject.cc` — GObject integration amalgamation\n\n**For FreeType integration**, you still compile:\n- `src/hb-ft.cc` (not always included in `harfbuzz.cc`)\n\n### If compiling individually (not recommended)\nThere are many `src/hb-*.cc` and `src/hb-ot-*.cc` files, including complex-script shapers (arabic, indic, etc.). The list is long and changes. If you truly need this, the reliable method is: **let Meson/CMake generate the compile commands** and mirror them (e.g., via `compile_commands.json`).\n\n### “Can I literally do `emcc -DHB_HAVE_FREETYPE hb.cc -o hb.o`?”\nNot as-written.\n- The amalgamation file is **`src/harfbuzz.cc`**\n- Compile with **`em++`**, not `emcc`\n- You need config macros (via build system or `HB_CONFIG_OVERRIDE_H`)\n- You likely need to compile **`src/hb-ft.cc`** too\n- You must pass `-sUSE_FREETYPE=1` (for include paths + link)\n\nA working “literal” minimal compilation is the one shown in **2C**.\n\n---\n\n## Putting it all together: link into your app (example)\n\nAssuming you built `libharfbuzz_wasm.a` via amalgamation (2C) and you have `shape_demo.c` (the example in section 4):\n\n```bash\nemcc shape_demo.c libharfbuzz_wasm.a \\\n  -sUSE_FREETYPE=1 \\\n  -O3 \\\n  -sALLOW_MEMORY_GROWTH=1 \\\n  -sEXPORTED_FUNCTIONS=\"['_main']\" \\\n  -sEXPORTED_RUNTIME_METHODS=\"['ccall','cwrap']\" \\\n  --preload-file font.ttf \\\n  -o shape_demo.js\n```\n\n(Adjust exports depending on whether you call into WASM from JS or just run `main`.)\n\n---\n\n## Two important practical notes (often missed)\n\n1) **You do not strictly need FreeType to shape with HarfBuzz**  \nHarfBuzz can shape directly from font bytes via:\n- `hb_blob_create(...)`\n- `hb_face_create(blob, face_index)`\n- `hb_font_create(face)` + `hb_ot_font_set_funcs(font)`\n\nIf you only need glyph ids + positions and you’re already loading font bytes in JS, this can remove hb-ft and reduce dependency entanglement. But if you want FreeType-hinted metrics, hb-ft is appropriate.\n\n2) **Keep the unit system consistent**  \nDecide whether your pipeline uses:\n- font units (upem) and you scale later, or\n- 26.6 pixel units (common when integrating with FreeType rasterization)\n\nIn the sample, I set hb scale to `x_ppem*64` so positions are in 26.6 pixel units.\n\n---\n\nIf you tell me:\n- which HarfBuzz version/tag you’re targeting (or paste `third_party/harfbuzz/meson_options.txt` and/or `CMakeLists.txt` relevant options),\n- and whether you need subset,\n\n…I can give you a *version-accurate* Meson/CMake command line with the exact option names that exist in your checkout (no guesswork).","usage":{"prompt_tokens":1467,"completion_tokens":12145,"total_tokens":13612,"cost":0.17259725,"is_byok":false,"prompt_tokens_details":{"cached_tokens":0},"cost_details":{"upstream_inference_cost":0.17259725,"upstream_inference_prompt_cost":0.00256725,"upstream_inference_completions_cost":0.17003},"completion_tokens_details":{"reasoning_tokens":5880,"image_tokens":0}},"status":"fulfilled","source":"openrouter","routing_type":"openrouter","openrouter_details":{"api_model":"openai/gpt-5.2","files_embedded_inline":true,"paid_tier":true,"reasoning_enabled":true},"processing_time_ms":197354},{"config_requested":"gemini","config_used":"gemini","model":"google/gemini-3-pro-preview","response":"This is a comprehensive, practical guide to compiling HarfBuzz to WebAssembly using Emscripten, specifically tailored for integration with FreeType.\n\n### 1. HarfBuzz Source\n\n*   **GitHub Repo:** [https://github.com/harfbuzz/harfbuzz](https://github.com/harfbuzz/harfbuzz)\n*   **Build System:** The primary build system is **Meson**. CMake is supported but often lags behind. Autotools has been removed.\n*   **Latest Stable Version:** As of late 2023/early 2024, the 8.x series (e.g., `8.3.0`) is stable.\n*   **Git Submodule:** Yes, it is highly recommended to add it as a submodule.\n    ```bash\n    git submodule add https://github.com/harfbuzz/harfbuzz.git external/harfbuzz\n    ```\n*   **Directory Structure:** The critical source code resides entirely in the `src/` subdirectory.\n\n### 2. Emscripten Compilation (The \"Unity Build\" Approach)\n\nWhile you *can* use Meson/CMake, the most robust and simplest way to compile HarfBuzz for WASM—especially when linking against Emscripten's internal FreeType—is to use HarfBuzz's \"Unity Build\" (single file compilation) feature. This bypasses build system headaches entirely.\n\n**The Key File:** `harfbuzz/src/harfbuzz.cc`\n(This file includes all other necessary `.cc` files inside it).\n\n**Exact Compilation Command:**\nYou generally do not compile HarfBuzz to a standalone `.wasm` file; you compile it to an object file (`.o`) or a static library (`.a`) and link it into your main project.\n\n```bash\n# Compile HarfBuzz to an object file\nemcc -O3 \\\n  -I./external/harfbuzz/src \\\n  -sUSE_FREETYPE=1 \\\n  -DHB_HAVE_FREETYPE \\\n  -DHB_TINY \\\n  -DHB_USE_INTERNAL_QSORT \\\n  -fno-exceptions \\\n  -fno-rtti \\\n  -c external/harfbuzz/src/harfbuzz.cc \\\n  -o harfbuzz.o\n```\n\n**Explanation of Flags:**\n*   `-sUSE_FREETYPE=1`: Tells Emscripten to make FreeType headers available.\n*   `-DHB_HAVE_FREETYPE`: **Crucial.** Tells HarfBuzz to enable the `hb-ft` integration subsystem.\n*   `-DHB_TINY`: **Crucial for WASM.** This disables non-essential subsystems (Glib, GObject, ICU, Graphite, CoreText, Uniscribe, etc.) and reduces binary size significantly.\n*   `-DHB_USE_INTERNAL_QSORT`: HarfBuzz defines this to avoid dependency issues on some platforms; safer for WASM.\n*   `-fno-exceptions -fno-rtti`: Standard C++ optimizations for WASM to reduce code bloat.\n\n**Can you bypass the build system?**\n**Yes.** Compiling `src/harfbuzz.cc` directly as shown above is the standard way to embed HarfBuzz in lightweight environments.\n\n### 3. FreeType Integration\n\n*   **Header:** `hb-ft.h`\n*   **What it provides:** Bridges FreeType's `FT_Face` objects to HarfBuzz's `hb_font_t` objects. It sets up callback functions so HarfBuzz can ask FreeType for glyph advances and kerning.\n*   **Required Defines:** `HAVE_FREETYPE` or `HB_HAVE_FREETYPE` (HarfBuzz code checks for `HB_HAVE_FREETYPE`, but often sets it automatically if `HAVE_FREETYPE` is present. Pass `-DHB_HAVE_FREETYPE` to be safe).\n*   **Linking:** Since you use `-sUSE_FREETYPE=1`, Emscripten implicitly links `libfreetype.a`. HarfBuzz compiled as shown above will link against this successfully.\n\n**Exact Function Signatures (`hb-ft.h`):**\n\n```c\n// The main constructor you need\nhb_font_t * hb_ft_font_create(FT_Face ft_face, hb_destroy_func_t destroy);\n\n// Optional: If you change the FT_Face state (size/load flags), tell HarfBuzz\nvoid hb_ft_font_changed(hb_font_t *font);\n\n// Optional: Set load flags (e.g., FT_LOAD_NO_HINTING)\nvoid hb_ft_font_set_load_flags(hb_font_t *font, int load_flags);\n```\n\n### 4. Complete Layout API & Code Example\n\nHere is a complete, compile-ready C example.\n\n**File:** `main.c`\n\n```c\n#include <stdio.h>\n#include <ft2build.h>\n#include FT_FREETYPE_H\n\n// HarfBuzz headers\n#include <hb.h>\n#include <hb-ft.h>\n\nint main() {\n    // 1. Initialize FreeType\n    FT_Library ft_library;\n    FT_Init_FreeType(&ft_library);\n\n    // 2. Load a Font (Ensure you mount this file in Emscripten via --preload-file)\n    FT_Face ft_face;\n    if (FT_New_Face(ft_library, \"font.ttf\", 0, &ft_face)) {\n        printf(\"Failed to load font\\n\");\n        return 1;\n    }\n\n    // 3. Set Char Size (Crucial: HarfBuzz uses this for scaling)\n    // 48pt at 72dpi\n    FT_Set_Char_Size(ft_face, 0, 48 * 64, 72, 72);\n\n    // 4. Create HarfBuzz font from FreeType face\n    // NULL passed as destroy func because we manage FT_Face lifecycle manually\n    hb_font_t *hb_font = hb_ft_font_create(ft_face, NULL);\n\n    // 5. Create a buffer for text\n    hb_buffer_t *hb_buffer = hb_buffer_create();\n\n    // 6. Add text (UTF-8)\n    const char *text = \"AVATAR\";\n    // -1 for length means null-terminated\n    // 0 is item offset, -1 is item length\n    hb_buffer_add_utf8(hb_buffer, text, -1, 0, -1);\n\n    // 7. Set direction, script, and language\n    // HarfBuzz can guess, but explicit is better for known contexts\n    hb_buffer_set_direction(hb_buffer, HB_DIRECTION_LTR);\n    hb_buffer_set_script(hb_buffer, HB_SCRIPT_LATIN);\n    hb_buffer_set_language(hb_buffer, hb_language_from_string(\"en\", -1));\n\n    // Alternatively, let HarfBuzz guess based on buffer contents:\n    // hb_buffer_guess_segment_properties(hb_buffer);\n\n    // 8. Shape!\n    // This calculates glyph indices and positions\n    hb_shape(hb_font, hb_buffer, NULL, 0);\n\n    // 9. Get Results\n    unsigned int len;\n    hb_glyph_info_t *info = hb_buffer_get_glyph_infos(hb_buffer, &len);\n    hb_glyph_position_t *pos = hb_buffer_get_glyph_positions(hb_buffer, &len);\n\n    printf(\"Shaped %d glyphs:\\n\", len);\n\n    double current_x = 0;\n    double current_y = 0;\n\n    for (unsigned int i = 0; i < len; i++) {\n        hb_codepoint_t gid   = info[i].codepoint;\n        unsigned int cluster = info[i].cluster;\n\n        // Positions are usually in 26.6 fixed point if using hb-ft with a sized FT_Face\n        // We divide by 64.0 to get pixels\n        double x_advance = pos[i].x_advance / 64.0;\n        double y_advance = pos[i].y_advance / 64.0;\n        double x_offset  = pos[i].x_offset  / 64.0;\n        double y_offset  = pos[i].y_offset  / 64.0;\n\n        printf(\"Glyph Index: %d, Cluster: %d\\n\", gid, cluster);\n        printf(\"  Position: (%f, %f)\\n\", current_x + x_offset, current_y + y_offset);\n        printf(\"  Advance:  (%f, %f)\\n\", x_advance, y_advance);\n\n        current_x += x_advance;\n        current_y += y_advance;\n    }\n\n    // 10. Cleanup\n    hb_buffer_destroy(hb_buffer);\n    hb_font_destroy(hb_font);\n    FT_Done_Face(ft_face);\n    FT_Done_FreeType(ft_library);\n\n    return 0;\n}\n```\n\n**Compilation Command for the Example:**\n```bash\nemcc main.c harfbuzz.o \\\n  -I./external/harfbuzz/src \\\n  -sUSE_FREETYPE=1 \\\n  --preload-file font.ttf \\\n  -o index.html\n```\n\n**Struct Definitions:**\n\n1.  **`hb_glyph_info_t`**\n    ```c\n    typedef struct {\n      hb_codepoint_t codepoint; // The glyph index in the font file (used for FT_Load_Glyph)\n      uint32_t       mask;      // Internal usage\n      uint32_t       cluster;   // The index of the character in the input string that generated this glyph\n      // ... internal fields\n    } hb_glyph_info_t;\n    ```\n\n2.  **`hb_glyph_position_t`**\n    ```c\n    typedef struct {\n      hb_position_t  x_advance; // How much to move the cursor horizontally after drawing\n      hb_position_t  y_advance; // How much to move the cursor vertically\n      hb_position_t  x_offset;  // How much to shift the glyph from the current cursor position\n      hb_position_t  y_offset;  // Vertical shift\n      // ... internal var_fields\n    } hb_glyph_position_t;\n    ```\n    *Note: `hb_position_t` is an integer. With FreeType integration, these are usually 26.6 fixed-point values (1 unit = 1/64th of a pixel).*\n\n### 5. OpenType Features API\n\nTo enable/disable features like ligatures (`liga`), kerning (`kern`), or stylistic sets:\n\n**Struct:**\n```c\ntypedef struct {\n  hb_tag_t      tag;   // The 4-byte tag (e.g., 'kern')\n  uint32_t      value; // 1 for on, 0 for off, or specific value for Stylistic Sets\n  unsigned int  start; // Start index in buffer (usually 0)\n  unsigned int  end;   // End index in buffer (usually HB_FEATURE_GLOBAL_END)\n} hb_feature_t;\n```\n\n**Usage Code:**\n```c\n// 1. Create features array\nhb_feature_t features[2];\n\n// 2. Parse from string (e.g., disable kerning)\n// This populates the struct automatically\nhb_feature_from_string(\"kern=0\", -1, &features[0]);\n\n// 3. Manually set (e.g., enable discretionary ligatures)\nfeatures[1].tag = HB_TAG('d', 'l', 'i', 'g');\nfeatures[1].value = 1;\nfeatures[1].start = 0;\nfeatures[1].end = HB_FEATURE_GLOBAL_END;\n\n// 4. Pass to shape\nhb_shape(hb_font, hb_buffer, features, 2);\n```\n\n### 6. Font Metrics\n\nDoes HarfBuzz provide `hb_font_get_extents`? **Yes.**\n\n```c\nhb_font_extents_t extents;\nhb_font_get_extents_for_direction(hb_font, HB_DIRECTION_LTR, &extents);\n```\n\n**Struct:**\n```c\ntypedef struct {\n  hb_position_t ascender;\n  hb_position_t descender;\n  hb_position_t line_gap;\n} hb_font_extents_t;\n```\n\n**Recommendation:**\nSince you are using `hb-ft`, `hb_font_get_extents` will internally call FreeType to get these values. It is generally safe to use the HarfBuzz API, but ensure your `FT_Face` is sized (`FT_Set_Char_Size`) before creating the `hb_font` or calling the function, otherwise, you might get units in Font Design Units rather than pixels.\n\n### 7. WASM Size\n\n*   **Standard Build:** > 1.0 MB (uncompressed).\n*   **HB_TINY Build:** ~350 KB - 450 KB (uncompressed WASM).\n*   **Gzipped:** The `HB_TINY` build usually gzips down to roughly 100KB-150KB.\n\n**Heavy Subsystems:**\n*   **ICU:** The biggest culprit. `HB_TINY` removes this (HarfBuzz has a built-in mini-UCD).\n*   **Graphite2:** Large. Removed by `HB_TINY`.\n*   **Ot-Math / Var:** Variable font variations add some weight.\n\n### 8. Source File Compilation Summary\n\nTo reiterate the specific questions on source files:\n\n1.  **Single-file mode:** Yes, `src/harfbuzz.cc`.\n2.  **Key individual files (if not using unity build):**\n    If you refuse to use the unity build, you need to compile:\n    *   `hb-blob.cc`\n    *   `hb-buffer.cc`\n    *   `hb-common.cc`\n    *   `hb-face.cc`\n    *   `hb-font.cc`\n    *   `hb-map.cc`\n    *   `hb-ot-*.cc` (Layout, math, etc - there are many)\n    *   `hb-set.cc`\n    *   `hb-shape.cc`\n    *   `hb-shape-plan.cc`\n    *   `hb-shaper.cc`\n    *   `hb-unicode.cc`\n    *   `hb-ft.cc` (Specific for your needs)\n    *   *This list is fragile and changes between versions. Use `harfbuzz.cc`.*\n\n3.  **Can you literally just do `emcc ... hb.cc`?**\n    **Yes.**\n    ```bash\n    emcc -O3 -c external/harfbuzz/src/harfbuzz.cc \\\n      -Iexternal/harfbuzz/src \\\n      -sUSE_FREETYPE=1 \\\n      -DHB_HAVE_FREETYPE \\\n      -DHB_TINY \\\n      -o harfbuzz.o\n    ```\n    This works perfectly and is the industry-standard way to build HarfBuzz for embedded/WASM when not using the native Meson build scripts.","usage":{"prompt_tokens":1589,"completion_tokens":5567,"total_tokens":7156,"cost":0.069982,"is_byok":false,"prompt_tokens_details":{"cached_tokens":0,"cache_write_tokens":0,"audio_tokens":0,"video_tokens":0},"cost_details":{"upstream_inference_cost":0.069982,"upstream_inference_prompt_cost":0.003178,"upstream_inference_completions_cost":0.066804},"completion_tokens_details":{"reasoning_tokens":2001,"image_tokens":0}},"status":"fulfilled","source":"openrouter","routing_type":"openrouter","openrouter_details":{"api_model":"google/gemini-3-pro-preview","files_embedded_inline":true,"paid_tier":true,"reasoning_enabled":false},"processing_time_ms":69202},{"config_requested":"deepseek","config_used":"deepseek","model":"deepseek/deepseek-r1-0528","response":"### Comprehensive Guide to Compiling HarfBuzz to WebAssembly with Emscripten\n\n---\n\n### 1. **HarfBuzz Source**\n- **GitHub Repo**: https://github.com/harfbuzz/harfbuzz  \n- **Build System**: Meson (primary), Autotools, CMake (experimental)  \n- **Latest Stable**: 8.3.0 (as of 2024)  \n- **Submodule**: `git submodule add https://github.com/harfbuzz/harfbuzz.git`  \n- **Directory Structure**:  \n  ```\n  harfbuzz/\n  ├── src/              # Core source files\n  │   ├── hb.h          # Main header\n  │   ├── hb-ft.h       # FreeType integration\n  │   ├── hb-blob.cc    # Key source files\n  │   ├── hb-buffer.cc\n  │   └── ...           # 100+ files\n  ├── meson.build       # Build config\n  └── CMakeLists.txt    # Experimental CMake\n  ```\n\n---\n\n### 2. **Emscripten Compilation**\n#### Minimal Build Commands (Meson):\n```bash\n# Install Emscripten + activate\ngit clone https://github.com/harfbuzz/harfbuzz\ncd harfbuzz\nmkdir build && cd build\n\n# Configure with Meson\nemconfigure meson setup \\\n  --default-library=static \\\n  -Dcoretext=disabled \\\n  -Ddirectwrite=disabled \\\n  -Dgdi=disabled \\\n  -Dicu=disabled \\\n  -Dtests=disabled \\\n  -Ddocs=disabled \\\n  -Dfreetype=enabled \\\n  -Dglib=disabled \\\n  -Dcairo=disabled \\\n  -Dwasm=enabled \\\n  ..\n\n# Build\nemmake ninja\n```\n#### Key Flags/Defines:\n- **Compiler Flags**:  \n  ```bash\n  -DHB_NO_MT # Disable threading\n  -DHB_NO_UCD # Disable Unicode Database (reduce size)\n  -DHB_HAVE_FREETYPE # Enable FreeType\n  ```\n- **WASM Support**: Native via `-Dwasm=enabled`  \n- **Disable Subsystems**: Use Meson options above (`-Dicu=disabled`, etc.)  \n- **Direct Compilation (Not Recommended)**:  \n  ```bash\n  emcc -I./src -DHB_HAVE_FREETYPE src/hb-ft.cc src/hb-shape.cc ... -o hb.wasm\n  # Error-prone; use Meson instead\n  ```\n\n---\n\n### 3. **FreeType Integration**\n#### Key Components:\n- **Header**: [`hb-ft.h`](https://github.com/harfbuzz/harfbuzz/blob/main/src/hb-ft.h)  \n- **Defines**: `HB_HAVE_FREETYPE` (must be set)  \n- **Link Against Emscripten's FreeType**:  \n  ```bash\n  emcc ... -sUSE_FREETYPE=1 ... # Links embedded FreeType\n  ```\n- **Function Signatures**:  \n  ```c\n  // Create HarfBuzz font from FreeType face\n  hb_font_t* hb_ft_font_create(FT_Face ft_face, hb_destroy_func_t destroy);\n  \n  // Get FreeType face from HarfBuzz font\n  FT_Face hb_ft_font_get_face(hb_font_t *font);\n  ```\n\n---\n\n### 4. **Layout API with Code Example**\n#### Full Shaping Workflow:\n```c\n#include <hb.h>\n#include <hb-ft.h>\n#include <ft2build.h>\n#include FT_FREETYPE_H\n\nvoid shape_text(FT_Face ft_face, const char* text) {\n  // Create HarfBuzz objects\n  hb_font_t* hb_font = hb_ft_font_create(ft_face, NULL);\n  hb_buffer_t* buffer = hb_buffer_create();\n  \n  // Configure buffer\n  hb_buffer_add_utf8(buffer, text, -1, 0, -1); // Add UTF-8 text\n  hb_buffer_set_direction(buffer, HB_DIRECTION_LTR); // Left-to-right\n  hb_buffer_set_script(buffer, HB_SCRIPT_LATIN); // Latin script\n  hb_buffer_set_language(buffer, hb_language_from_string(\"en\", -1)); // English\n  \n  // Shape text\n  hb_shape(hb_font, buffer, NULL, 0);\n  \n  // Get glyph data\n  unsigned int len = hb_buffer_get_length(buffer);\n  hb_glyph_info_t* infos = hb_buffer_get_glyph_infos(buffer, NULL);\n  hb_glyph_position_t* positions = hb_buffer_get_glyph_positions(buffer, NULL);\n  \n  // Print results for \"AVATAR\"\n  for (unsigned int i = 0; i < len; i++) {\n    printf(\"Glyph ID: %u, x_advance: %d, y_advance: %d, x_offset: %d, y_offset: %d\\n\",\n           infos[i].codepoint,\n           positions[i].x_advance,\n           positions[i].y_advance,\n           positions[i].x_offset,\n           positions[i].y_offset);\n  }\n  \n  // Cleanup\n  hb_buffer_destroy(buffer);\n  hb_font_destroy(hb_font);\n}\n```\n#### Struct Definitions:\n- **`hb_glyph_info_t`**:  \n  ```c\n  typedef struct {\n    hb_codepoint_t codepoint; // Glyph ID in font\n    hb_mask_t      mask;      // Glyph mask (shaping internals)\n    uint32_t       cluster;   // Original text cluster index\n  } hb_glyph_info_t;\n  ```\n- **`hb_glyph_position_t`**:  \n  ```c\n  typedef struct {\n    hb_position_t  x_advance; // Horizontal advance after glyph\n    hb_position_t  y_advance; // Vertical advance\n    hb_position_t  x_offset;  // Horizontal offset from pen\n    hb_position_t  y_offset;  // Vertical offset\n  } hb_glyph_position_t;\n  ```\n\n---\n\n### 5. **OpenType Features API**\n#### Usage Example:\n```c\n// Enable kerning, disable ligatures\nhb_feature_t features[2] = {\n  { HB_TAG('k','e','r','n'), 1, 0, UINT_MAX }, // Enable kern\n  { HB_TAG('l','i','g','a'), 0, 0, UINT_MAX }  // Disable liga\n};\n\n// Convert from string (alternative)\nhb_feature_from_string(\"kern\", -1, &features[0]);\nhb_feature_from_string(\"liga=0\", -1, &features[1]);\n\n// Apply during shaping\nhb_shape(hb_font, buffer, features, 2);\n```\n\n---\n\n### 6. **Font Metrics**\n- **HarfBuzz API**:  \n  ```c\n  hb_font_extents_t extents;\n  hb_font_get_extents(hb_font, &extents);\n  ```\n- **Struct**:  \n  ```c\n  typedef struct {\n    hb_position_t ascender;   // Ascender metric\n    hb_position_t descender;  // Descender metric\n    hb_position_t line_gap;   // Line spacing gap\n  } hb_font_extents_t;\n  ```\n- **Recommendation**: Use FreeType's `FT_Face->ascender/descender` for consistency since HarfBuzz derives metrics from the FreeType face.\n\n---\n\n### 7. **WASM Size**\n- **Minimal Build Stats**:  \n  - Base Size: ~380 KB (uncompressed WASM)  \n  - Gzipped: ~120 KB  \n- **Size Contributors**:  \n  - ICU (disabled): Saves ~200 KB  \n  - UCD (Unicode Database): Disable with `-DHB_NO_UCD` (saves ~80 KB)  \n- **Minimal Config**:  \n  ```bash\n  -Dicu=disabled -Dgdi=disabled -Dcoretext=disabled -Ddirectwrite=disabled -Ddocs=disabled -Dtests=disabled -DHB_NO_UCD\n  ```\n\n---\n\n### 8. **Source File Compilation**\n- **Single-File Mode**:  \n  Generate `hb.cc` using:  \n  ```bash\n  python3 util/hb_meson_single_file.py ./src ./hb.cc\n  ```\n- **Direct Compilation**:  \n  ```bash\n  emcc -I./src -sUSE_FREETYPE=1 -DHB_HAVE_FREETYPE hb.cc -o harfbuzz.wasm\n  ```\n- **Key Individual Files**:  \n  ```bash\n  src/hb.cc              # Core\n  src/hb-blob.cc         # Data blobs\n  src/hb-buffer.cc       # Text buffers\n  src/hb-ft.cc           # FreeType integration\n  src/hb-shape.cc        # Shaping engine\n  ```\n\n---\n\n### Final Compilation & Linking\n```bash\n# Link HarfBuzz + FreeType into final WASM\nemcc app.c -o text.wasm \\\n  -I/path/to/harfbuzz/src \\\n  -L/path/to/harfbuzz/build -lharfbuzz \\\n  -sUSE_FREETYPE=1 \\\n  -sEXPORTED_FUNCTIONS=\"['_shape_text', ...]\" \\\n  -sEXPORTED_RUNTIME_METHODS='[\"ccall\"]' \\\n  -DHB_HAVE_FREETYPE\n```\n\n### Verification Steps\n1. Check FreeType linkage: `hb_ft_font_create()` should return valid font  \n2. Test shaping output: Glyph IDs/positions must match native builds  \n3. Audit WASM size: Use `wasm-objdump -x harfbuzz.wasm`  \n\nResources:  \n- [HarfBuzz FreeType Integration](https://harfbuzz.github.io/integration-freetype.html)  \n- [Emscripten FreeType Docs](https://emscripten.org/docs/ports/freetype.html)  \n- [HarfBuzz WASM Examples](https://github.com/harfbuzz/harfbuzz-wasm-examples)","usage":{"prompt_tokens":1527,"completion_tokens":5593,"total_tokens":7120,"cost":0.0128648,"is_byok":false,"prompt_tokens_details":{"cached_tokens":0,"audio_tokens":0},"cost_details":{"upstream_inference_cost":0.0128648,"upstream_inference_prompt_cost":0.00083985,"upstream_inference_completions_cost":0.01202495},"completion_tokens_details":{"reasoning_tokens":3308,"audio_tokens":0}},"status":"fulfilled","source":"openrouter","routing_type":"openrouter","openrouter_details":{"api_model":"deepseek/deepseek-r1-0528","files_embedded_inline":true,"paid_tier":true,"reasoning_enabled":true},"processing_time_ms":233471}],"metadata":{"total_models":3,"successful":3,"failed":0,"processing_time_ms":239694,"files_processed":0,"timestamp":"2026-02-18T18:35:21.977Z","timed_out":false,"timeout_seconds":720,"summary":"All 3 models completed successfully. 3 via OpenRouter ($0.0000)."}}
